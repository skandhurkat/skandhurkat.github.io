<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>programming on Skand Hurkat</title>
    <link>https://skandhurkat.com/tags/programming/</link>
    <description>Recent content in programming on Skand Hurkat</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 23 Nov 2017 16:28:40 -0500</lastBuildDate>
    
	<atom:link href="https://skandhurkat.com/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to CMake</title>
      <link>https://skandhurkat.com/post/intro-to-cmake/</link>
      <pubDate>Thu, 23 Nov 2017 16:28:40 -0500</pubDate>
      
      <guid>https://skandhurkat.com/post/intro-to-cmake/</guid>
      <description>CMake is cross-platform build and configuration system for C and C++ code, which also happens to be my favourite build system. In this post, I&amp;rsquo;ll present a quick tutorial on getting started with CMake.
But before we do, let&amp;rsquo;s start with an example of why other build systems such as Makefiles don&amp;rsquo;t necessarily cut it. Actually, Makefiles work fairly well, but writing Makefiles by hand is generally a pain in the neck.</description>
    </item>
    
    <item>
      <title>Handling dependencies in Makefiles</title>
      <link>https://skandhurkat.com/post/makefile-dependencies/</link>
      <pubDate>Wed, 02 Aug 2017 17:45:00 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/makefile-dependencies/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve seen way too many projects that supply a makefile that requires the
user to run &lt;code&gt;make clean&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; every single time they make a
change to some file. This is annoying and error prone, and the good news
is that it can be easily solved with this one simple trick. Use a good
build-generation system like &lt;a href=&#34;//cmake.org&#34; target=&#34;_blank&#34;&gt;CMake&lt;/a&gt; instead.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>An Introduction to CTest</title>
      <link>https://skandhurkat.com/post/intro-to-ctest/</link>
      <pubDate>Thu, 22 Jun 2017 11:05:43 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/intro-to-ctest/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve seen a lot of people (I&amp;rsquo;m looking at you &lt;a href=&#34;//lemire.me&#34; target=&#34;_blank&#34;&gt;Daniel
Lemire&lt;/a&gt;) praise newer languages like &lt;em&gt;Go&lt;/em&gt;, which makes me
sad as a C++ programmer. Well, that&amp;rsquo;s until I realise that most of the
features touted could be easily incorporated in C++ with just a bit of
elbow grease. In this post, I&amp;rsquo;ll show how to add an automated testing
system using CTest.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A bug in how GCC handles constructors</title>
      <link>https://skandhurkat.com/post/gcc-constructor-bug/</link>
      <pubDate>Tue, 23 May 2017 10:51:42 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/gcc-constructor-bug/</guid>
      <description>Some days ago, I became aware of a bug in GCC that has apparently existed since 2015. As this is a bug that deals with memory leaks, it is fairly serious.
In this case, I really don&amp;rsquo;t want to re-post the entire content of the source, so I will only list my experiments with reproducing the bug once I became aware of it.
C++ assumes that if a constructor fails, then no memory is allocated for the object at all.</description>
    </item>
    
    <item>
      <title>PSA: Don&#39;t use std::rand()</title>
      <link>https://skandhurkat.com/post/psa-dont-use-rand/</link>
      <pubDate>Sun, 16 Apr 2017 19:50:51 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/psa-dont-use-rand/</guid>
      <description>&lt;p&gt;With the &lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt; header in C++11 onwards, there really is no reason
to use &lt;code&gt;std::rand()&lt;/code&gt; to generate random numbers. In fact, using
&lt;code&gt;std::rand()&lt;/code&gt; could be really harmful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>On writing platform-independent code (or why I like the new C&#43;&#43;)</title>
      <link>https://skandhurkat.com/post/why-i-like-cpp11/</link>
      <pubDate>Sat, 16 Mar 2013 17:26:35 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/why-i-like-cpp11/</guid>
      <description>I use Linux when I work from home, I&amp;rsquo;m forced to use a Mac at work (well, I boot up a virtual Linux OS), and I use Windows when I just want to goof around with my computer. So, while most of my work is done on Linux, it&amp;rsquo;s imperative that my code work on all platforms; just because I could use any of the three.
Traditionally, C required multiple versions of code, protected by #ifdefs.</description>
    </item>
    
    <item>
      <title>AutoHell v CMake</title>
      <link>https://skandhurkat.com/post/autohell-v-cmake/</link>
      <pubDate>Thu, 16 Aug 2012 17:24:18 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/autohell-v-cmake/</guid>
      <description>People familiar with the GNU/Unix system would know that the standard way to install about any GNU software from code is to run the following commands
configure make sudo make install  These commands are from the GNU autotools environment. Knowing the GNU environment, these tools are what I used to compile most of the (relatively small) pieces of code I wrote.
Until I discovered CMake.
CMake, or Cross-platform Make is a tool that serves the same functionality as the GNU autotools (hereafter referred to as autohell).</description>
    </item>
    
  </channel>
</rss>