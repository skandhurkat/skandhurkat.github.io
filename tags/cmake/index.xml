<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cmake on Skand Hurkat</title>
    <link>https://skandhurkat.com/tags/cmake/</link>
    <description>Recent content in cmake on Skand Hurkat</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; {year} Skand Hurkat. All rights reserved.</copyright>
    <lastBuildDate>Thu, 23 Nov 2017 16:28:40 -0500</lastBuildDate>
    
	<atom:link href="https://skandhurkat.com/tags/cmake/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to CMake</title>
      <link>https://skandhurkat.com/post/intro-to-cmake/</link>
      <pubDate>Thu, 23 Nov 2017 16:28:40 -0500</pubDate>
      
      <guid>https://skandhurkat.com/post/intro-to-cmake/</guid>
      <description>CMake is cross-platform build and configuration system for C and C++ code, which also happens to be my favourite build system. In this post, I&amp;rsquo;ll present a quick tutorial on getting started with CMake.
But before we do, let&amp;rsquo;s start with an example of why other build systems such as Makefiles don&amp;rsquo;t necessarily cut it. Actually, Makefiles work fairly well, but writing Makefiles by hand is generally a pain in the neck.</description>
    </item>
    
    <item>
      <title>An Introduction to CTest</title>
      <link>https://skandhurkat.com/post/intro-to-ctest/</link>
      <pubDate>Thu, 22 Jun 2017 11:05:43 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/intro-to-ctest/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve seen a lot of people (I&amp;rsquo;m looking at you &lt;a href=&#34;//lemire.me&#34; target=&#34;_blank&#34;&gt;Daniel
Lemire&lt;/a&gt;) praise newer languages like &lt;em&gt;Go&lt;/em&gt;, which makes me
sad as a C++ programmer. Well, that&amp;rsquo;s until I realise that most of the
features touted could be easily incorporated in C++ with just a bit of
elbow grease. In this post, I&amp;rsquo;ll show how to add an automated testing
system using CTest.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>On writing platform-independent code (or why I like the new C&#43;&#43;)</title>
      <link>https://skandhurkat.com/post/why-i-like-cpp11/</link>
      <pubDate>Sat, 16 Mar 2013 17:26:35 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/why-i-like-cpp11/</guid>
      <description>I use Linux when I work from home, I&amp;rsquo;m forced to use a Mac at work (well, I boot up a virtual Linux OS), and I use Windows when I just want to goof around with my computer. So, while most of my work is done on Linux, it&amp;rsquo;s imperative that my code work on all platforms; just because I could use any of the three.
Traditionally, C required multiple versions of code, protected by #ifdefs.</description>
    </item>
    
    <item>
      <title>AutoHell v CMake</title>
      <link>https://skandhurkat.com/post/autohell-v-cmake/</link>
      <pubDate>Thu, 16 Aug 2012 17:24:18 -0400</pubDate>
      
      <guid>https://skandhurkat.com/post/autohell-v-cmake/</guid>
      <description>People familiar with the GNU/Unix system would know that the standard way to install about any GNU software from code is to run the following commands
configure make sudo make install  These commands are from the GNU autotools environment. Knowing the GNU environment, these tools are what I used to compile most of the (relatively small) pieces of code I wrote.
Until I discovered CMake.
CMake, or Cross-platform Make is a tool that serves the same functionality as the GNU autotools (hereafter referred to as autohell).</description>
    </item>
    
  </channel>
</rss>